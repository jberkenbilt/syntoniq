use crate::engine::PlayedNote;
use crate::layout::Layout;
use crate::scale::{Note, ScaleDescription};
use askama::Template;
use std::collections::{HashMap, HashSet};
use std::fmt::{Display, Formatter};
use std::sync::Arc;
use syntoniq_common::pitch::Pitch;
use tokio::sync::broadcast::error::RecvError;
#[cfg(test)]
use tokio::sync::mpsc;
use tokio::sync::{RwLock, broadcast};

mod rgb_colors;

pub(super) mod colors {
    pub const WHITE: u8 = 0x03;
    pub const BLUE: u8 = 0x4f;
    pub const GREEN: u8 = 0x15;
    pub const PURPLE: u8 = 0x31;
    pub const PINK: u8 = 0x38;
    pub const RED: u8 = 0x06;
    pub const ORANGE: u8 = 0x09;
    pub const CYAN: u8 = 0x27;
    pub const YELLOW: u8 = 0x0d;
    pub const DULL_GRAY: u8 = 0x47;
    pub const HIGHLIGHT_GRAY: u8 = 0x01;
    pub const MAGENTA: u8 = 0x5e;
}

pub mod keys {
    // Top Row, left to right
    pub const SHIFT: u8 = 90;
    pub const TRANSPOSE: u8 = 94; // Note
    pub const SUSTAIN: u8 = 95; // Chord
    // Left column, top to bottom
    pub const UP_ARROW: u8 = 80;
    pub const DOWN_ARROW: u8 = 70;
    pub const CLEAR: u8 = 60;
    pub const RECORD: u8 = 10;
    // Right column, top to bottom
    pub const LAYOUT_SCROLL: u8 = 19;
    // Upper bottom controls
    pub const LAYOUT_MIN: u8 = 101;
    pub const LAYOUT_MAX: u8 = 109;
}

#[derive(Copy, Clone, Debug, PartialEq, Hash, Eq)]
pub enum Color {
    Off,
    Active,
    ToggleOff,
    ToggleOn,
    FifthOff,
    FifthOn,
    MajorThirdOff,
    MajorThirdOn,
    MinorThirdOff,
    MinorThirdOn,
    TonicOff,
    TonicOn,
    SingleStepOff,
    SingleStepOn,
    OtherOff,
    OtherOn,
    NoteSelected,
}
impl Color {
    pub fn launchpad_color(&self) -> u8 {
        match self {
            Color::Off => 0,
            Color::Active => colors::WHITE,
            Color::ToggleOff => colors::RED,
            Color::ToggleOn => colors::GREEN,
            Color::FifthOff => colors::BLUE,
            Color::FifthOn => colors::GREEN,
            Color::MajorThirdOff => colors::PURPLE,
            Color::MajorThirdOn => colors::PINK,
            Color::MinorThirdOff => colors::RED,
            Color::MinorThirdOn => colors::ORANGE,
            Color::TonicOff => colors::CYAN,
            Color::TonicOn => colors::YELLOW,
            Color::OtherOff => colors::DULL_GRAY,
            Color::OtherOn => colors::WHITE,
            Color::SingleStepOff => colors::HIGHLIGHT_GRAY,
            Color::SingleStepOn => colors::WHITE,
            Color::NoteSelected => colors::MAGENTA,
        }
    }

    pub fn rgb_color(&self) -> &'static str {
        rgb_colors::RGB_COLORS[self.launchpad_color() as usize]
    }
}

#[derive(Clone, Debug)]
pub struct LightEvent {
    pub position: u8,
    pub color: Color,
    pub label1: String,
    pub label2: String,
}
#[derive(Clone, Debug)]
pub struct KeyEvent {
    /// Midi note number
    pub key: u8,
    /// 0..127, 0 = off
    pub velocity: u8,
    /// Events generated by the engine in response to other events are synthetic. This can
    /// happen during layout selection.
    pub synthetic: bool,
}
#[derive(Clone, Debug)]
pub struct PressureEvent {
    pub key: Option<u8>,
    pub velocity: u8,
}

#[derive(Clone, Debug)]
pub struct LayoutNamesEvent {
    pub names: Vec<String>,
}

#[derive(Clone, Debug)]
pub struct SelectLayoutEvent {
    pub idx: usize,
    pub layout: Arc<RwLock<Layout>>,
}

#[derive(Clone, Debug)]
pub struct UpdateNoteEvent {
    pub position: u8,
    pub played_note: Option<PlayedNote>,
}

#[derive(Clone, Debug)]
pub struct PlayNoteEvent {
    pub pitch: Pitch,
    pub velocity: u8,
    pub note: Option<Arc<Note>>,
}

#[derive(Default, Debug, Copy, Clone, PartialEq)]
pub enum ShiftKeyState {
    #[default]
    Off, // Next on event turns on
    On,   // Next off event turns on
    Down, // Next off event leaves on
}

#[derive(Debug, Clone)]
pub struct SpecificNote {
    pub layout_idx: usize,
    pub note: Arc<Note>,
    pub position: u8,
}

#[derive(Default, Debug, Clone)]
pub enum TransposeState {
    #[default]
    Off,
    Pending {
        initial_layout: usize,
    },
    FirstSelected {
        initial_layout: usize,
        note1: SpecificNote,
    },
}

#[derive(Default, Debug, Clone)]
pub enum ShiftLayoutState {
    #[default]
    Off,
    FirstSelected(SpecificNote),
}

#[derive(Default, Clone, Debug)]
pub struct EngineState {
    /// Currently selected layout
    pub layout: Option<usize>,
    /// Offset from 1 of layout on first position
    pub layout_offset: usize,
    /// All available layouts
    pub layouts: Vec<Arc<RwLock<Layout>>>,
    /// Mapping from position to note in the current layout
    pub notes: HashMap<u8, Option<Arc<Note>>>,
    /// Mapping from pitch to all positions with that pitch in the current layout
    pub pitch_positions: HashMap<Pitch, HashSet<u8>>,
    /// Number of times a pitch is on; > 1 if simultaneously touching more than one position
    /// with the same pitch in non-sustain mode
    pub pitch_on_count: HashMap<Pitch, u8>,
    /// Last note played for a given pitch
    pub last_note_for_pitch: HashMap<Pitch, Arc<Note>>,
    /// Positions that are actually being touched
    pub positions_down: HashMap<u8, Arc<Note>>,
    pub sustain: bool,
    pub shift_key_state: ShiftKeyState,
    pub transpose_state: TransposeState,
    pub shift_layout_state: ShiftLayoutState,
}
impl EngineState {
    pub fn layout_at_position(&self, position: u8) -> Option<(usize, Arc<RwLock<Layout>>)> {
        let idx = (position - keys::LAYOUT_MIN) as usize + self.layout_offset;
        let layout = self.layouts.get(idx).cloned();
        layout.map(|x| (idx, x))
    }

    pub fn current_layout(&self) -> Option<Arc<RwLock<Layout>>> {
        self.layout.and_then(|x| self.layouts.get(x).cloned())
    }

    pub fn current_played_notes(&self) -> Vec<String> {
        // It would more efficient to directly print, but this is not performance-critical,
        // and generating a Vec makes testing easier.
        let mut result = Vec::new();
        // Scale name -> notes in the scale
        let mut scale_to_notes: HashMap<ScaleDescription, Vec<&Arc<Note>>> = HashMap::new();
        for note in self.last_note_for_pitch.values() {
            let key = note.scale_description.clone();
            scale_to_notes.entry(key).or_default().push(note);
        }
        let mut keys: Vec<ScaleDescription> = scale_to_notes.keys().cloned().collect();
        keys.sort();
        for scale in keys {
            result.push(format!("Scale: {scale}"));
            let mut notes = scale_to_notes.remove(&scale).unwrap();
            notes.sort_by_key(|note| note.pitch.clone());
            for note in notes {
                let Note {
                    name,
                    description,
                    pitch,
                    scale_description,
                    base_factor,
                    colors: _,
                } = note.as_ref();
                let scale_base_pitch = &scale_description.base_pitch;
                result.push(format!(
                    "  Note: {name} ({description}), pitch={pitch} ({scale_base_pitch} Ã— {base_factor})"
                ));
            }
        }
        result
    }
}

#[derive(Template, Default, Clone)]
#[template(path = "state-view.html")]
pub struct StateView {
    pub selected_layout: String,
    pub scale_name: String,
    pub base_pitch: String,
    pub layout_names: Vec<String>,
}

#[cfg(test)]
#[derive(Clone, Copy, Debug, PartialEq)]
pub enum TestEvent {
    ResetComplete,
    LayoutSelected,
    LayoutsScrolled,
    HandledNote,
    HandledKey,
    MoveCanceled,
    Sync,
}

#[derive(Clone, Debug)]
pub enum Event {
    Shutdown,
    Light(LightEvent),
    Key(KeyEvent),
    Pressure(PressureEvent),
    Reset,
    SetLayoutNames(LayoutNamesEvent),
    SelectLayout(SelectLayoutEvent),
    ScrollLayouts,
    UpdateNote(UpdateNoteEvent),
    PlayNote(PlayNoteEvent),
    #[cfg(test)]
    TestEngine(mpsc::Sender<EngineState>),
    #[cfg(test)]
    TestWeb(mpsc::Sender<StateView>),
    #[cfg(test)]
    TestEvent(TestEvent),
    #[cfg(test)]
    TestSync,
}

impl Display for Event {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        match self {
            Event::Light(LightEvent {
                position, color, ..
            }) => write!(f, "light: position={position}, color={color:?}"),
            Event::Key(KeyEvent {
                key,
                velocity,
                synthetic,
            }) => {
                write!(f, "key: key={key:02}, velocity={velocity}")?;
                if *synthetic {
                    write!(f, " (synthetic)")?;
                }
                Ok(())
            }
            Event::Pressure(PressureEvent { key, velocity }) => write!(
                f,
                "pressure: key={}, velocity={velocity}",
                key.map(|x| format!("{x:02}"))
                    .unwrap_or("global".to_string())
            ),
            _ => write!(f, "{self:?}"),
        }
    }
}

pub type UpgradedSender = broadcast::Sender<Event>;
pub type WeakSender = broadcast::WeakSender<Event>;
pub type Receiver = broadcast::Receiver<Event>;

pub struct Events {
    tx: RwLock<Option<UpgradedSender>>,
    rx: Receiver,
}

impl Default for Events {
    fn default() -> Self {
        Self::new()
    }
}

/// Receive an event, ignoring lag
pub async fn receive_check_lag(rx: &mut Receiver, warn_prefix: Option<&str>) -> Option<Event> {
    loop {
        let event = rx.recv().await;
        match event {
            Ok(Event::Shutdown) => return None,
            Ok(event) => return Some(event),
            Err(err) => match err {
                RecvError::Closed => return None,
                RecvError::Lagged(n) => {
                    if let Some(p) = warn_prefix {
                        log::warn!("{p}: missed {n} events");
                    }
                    continue;
                }
            },
        }
    }
}

impl Events {
    pub fn new() -> Self {
        let (tx, rx) = broadcast::channel(1000);
        Self {
            tx: RwLock::new(Some(tx)),
            rx,
        }
    }

    pub async fn sender(&self) -> WeakSender {
        let tx = self
            .tx
            .read()
            .await
            .clone()
            .expect("sender called after shutdown");
        tx.downgrade()
    }

    pub fn receiver(&self) -> Receiver {
        self.rx.resubscribe()
    }

    pub async fn shutdown(&self) {
        self.tx.write().await.take();
    }
}

#!/usr/bin/env python3
import os
import sys
import argparse
import glob
import re
import hashlib
import subprocess

whoami = os.path.basename(sys.argv[0])
whereami = os.path.dirname(os.path.realpath(__file__))
CONTENT = os.path.join(whereami, 'content')
OUT = os.path.join(whereami, 'static')
IN = os.path.join(whereami, 'static-src')


class _Main:
    def main(self, args=sys.argv[1:], prog=whoami):
        options = self.parse_args(args, prog)
        self.top(options)

    def parse_args(self, args, prog):
        parser = argparse.ArgumentParser(
            prog=prog,
            description='manage auto-generated content',
        )
        return parser.parse_args(args)

    @staticmethod
    def get_checksum(filename):
        m = hashlib.sha256()
        with open(filename, 'rb') as f:
            m.update(f.read())
        return m.hexdigest()

    @staticmethod
    def handle(filename):
        fullpath = os.path.join(CONTENT, filename)
        with open(fullpath, 'r') as f:
            lines = f.readlines()
        out = []
        consume_until_end = False
        for (n, line) in enumerate(lines):
            lineno = n + 1
            if consume_until_end:
                if line.strip() == '<!-- generate-end -->':
                    consume_until_end = False
                continue
            m = re.match('^<!-- generate (.*?) -->$', line.strip())
            if not m:
                out.append(line)
                continue
            args = m.group(1).split(' ')
            attrs = {}
            for arg in args:
                fields = arg.split('=')
                if len(fields) != 2:
                    exit(f"{filename}:{lineno}: can't parse {arg}")
                attrs[fields[0]] = fields[1]
            # Keep README.md up-to-date as syntax is added.
            if 'include' in attrs:
                input_file = attrs['include']
                input_path = os.path.join(IN, input_file)
                wanted = attrs.get('checksum', '')
                try:
                    checksum = _Main.get_checksum(input_path)
                except FileNotFoundError:
                    exit(f"{filename}:{lineno}: input {input_file} not found")
                if wanted == checksum:
                    out.append(line)
                    continue
                consume_until_end = True
                out.append(
                    f'<!-- generate include={input_file}'
                    f' checksum={checksum} -->\n')
                before = []
                after = []
                if input_file.endswith('.stq'):
                    before = ['```syntoniq\n']
                    after = ['```\n']
                out.extend(before)
                with open(input_path, 'r') as f2:
                    out.extend(f2.readlines())
                out.extend(after)
                out.extend('<!-- generate-end -->\n')
            if 'calc' in attrs:
                args_text = attrs['calc']
                args = args_text.split(',')
                consume_until_end = True
                p = subprocess.run([
                    'cargo',
                    'run',
                    '--bin',
                    'syntoniq',
                    'calc',
                    *args,
                ], stdout=subprocess.PIPE, stderr=subprocess.PIPE)
                if p.returncode == 0:
                    out_bytes = p.stdout
                else:
                    out_bytes = p.stderr
                out.extend(f'<!-- generate calc={args_text} -->\n')
                out.extend(
                    '```\n'
                    f'syntoniq calc {args_text.replace(",", " ")}\n'
                    '---\n'
                )
                out.extend(out_bytes.decode())
                out.extend('```\n')
                out.extend('<!-- generate-end -->\n')
        if lines != out:
            os.rename(fullpath, f'{fullpath}.auto-safe')
            with open(fullpath, 'w') as f:
                f.writelines(out)
            print(f'{filename}: updated')

    def top(self, options):
        files = glob.glob('*/*.md', root_dir=CONTENT)
        for f in files:
            self.handle(f)


if __name__ == '__main__':
    try:
        _Main().main()
    except KeyboardInterrupt:
        exit(130)
